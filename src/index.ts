import chokidar from 'chokidar'
import path from 'path'
import fs from 'fs/promises'
import globby from 'globby'
import { Options, PluginOptions } from './types'

const eol = '\n'

class GenerateExportsWebpackPlugin {
    defaultOptions: PluginOptions = {
        exportAll: false,
        exportAllAsAlias: true,
        omitExtension: true,
        omitSemi: false,
        singleQuote: true,
        filename: 'index.js',
        include: [],
        exclude: [],
        directories: [],
    }

    options!: PluginOptions[]

    constructor(options: Partial<PluginOptions> | Partial<PluginOptions>[] = []) {
        if (!Array.isArray(options)) {
            this.options = [{ ...this.defaultOptions, ...options }]
        } else {
            this.options = options.map((option) => ({
                ...this.defaultOptions,
                ...option,
            }))
        }
    }

    apply() {
        this.options.forEach((option, optionIndex) => {
            option.directories.forEach((directoryConfig) => {
                const directoryConfigIsArray = Array.isArray(directoryConfig)
                let directory = directoryConfigIsArray ? directoryConfig[0] : directoryConfig
                const options = directoryConfigIsArray ? { ...this.options[optionIndex], ...(directoryConfig[1] || {}) } : this.options[optionIndex]
                if (!path.isAbsolute(directory)) directory = path.resolve(directory)
                if (process.env.NODE_ENV === 'production') {
                    return this.generateIndex(directory, options)
                }
                const watcher = chokidar.watch(options.include, {
                    ignored: /^\./,
                    cwd: directory,
                })

                watcher
                    .on('add', (filePath) => this.handleFileChange(filePath, directory, options))
                    .on('unlink', (filePath) => this.handleFileChange(filePath, directory, options))
                    .on('ready', () => this.handleFileChange('', directory, options))
            })
        })
    }

    handleFileChange(filePath: string, directory, options) {
        if (filePath !== path.join(directory, options.filename)) {
            this.generateIndex(directory, options)
        }
    }

    btfs(path: string): string {
        return path.replace(/\\/g, '/')
    }

    async fileExists(path: string) {
        return !!(await fs.stat(path).catch((e) => false))
    }

    generateIndex(directory: string, options: PluginOptions | Options) {
        if (!path.isAbsolute(directory)) directory = path.resolve(directory)
        const { btfs } = this
        const { filename, include, exclude } = options
        const indexPath = btfs(path.join(directory, filename))
        globby(include, {
            cwd: directory,
            ignore: exclude,
        })
            .then((files) => {
                const filteredFiles = files.filter((file) => file !== filename)
                const indexTemplate = this.getTemplate(directory, options, filteredFiles)
                return this.fileExists(indexPath)
                    .then(async (exists) => {
                        if (exists) {
                            const fileContent = await fs.readFile(indexPath, 'utf8')
                            if (fileContent === indexTemplate) return Promise.reject('Contents are identical.')
                        }
                        return fs.mkdir(path.parse(indexPath).dir, { recursive: true })
                    })
                    .then(() => fs.writeFile(indexPath, indexTemplate))
            })
            .catch(() => {})
    }

    getTemplate(directory: string, options: PluginOptions | Options, files: string[]) {
        const { btfs } = this
        const { omitExtension, omitSemi, singleQuote, exportAll, exportAllAsAlias } = options
        const quoteType = singleQuote ? "'" : '"'
        return `/**
 * This file is auto-generated by GenerateExportsWebpackPlugin.
 * Check this file into source control.
 * Do not edit this file.
 */${eol}${files
            .sort((a, b) => a.localeCompare(b))
            .map((filePath) => {
                const { name } = path.parse(filePath)
                const exportRelativePath = btfs(
                    btfs(filePath)
                        .replace(btfs(directory), '')
                        .replace(omitExtension ? /\.[^/.]+$/ : '', '')
                )
                return `export ${exportAll ? `*${exportAllAsAlias ? ` as ${name}` : ``}` : `{ default as ${name} }`} from ${quoteType}${
                    exportRelativePath.startsWith('/') ? `.${exportRelativePath}` : `./${exportRelativePath}`
                }${quoteType}${omitSemi ? '' : ';'}`
            })
            .join(eol)}${eol}/* End of auto-generated content. */${eol}`
    }
}

module.exports = GenerateExportsWebpackPlugin
